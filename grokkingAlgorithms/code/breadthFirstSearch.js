// выражение отношений между элементами
// с помощью хеш-таблицы

// объект как отличная встроенная
// реализаця хеш-таблиц
const graph = {};

// свойству, выражающему нас
// присвоен массив наших друзей
graph["вы"] = ["Алиса", "Боб", "Клэр"];

// Список смежность для графа
// более сложной структуры
graph["вы"] = ["Алиса", "Боб", "Клэр"];
graph["Боб"] = ["Анудж", "Пегги"];
graph["Алиса"] = ["Пегги"];
graph["Клэр"] = ["Том", "Джонни"];
graph["Анудж"] = [];
graph["Пегги"] = [];
graph["Том"] = [];
graph["Джонни"] = [];

// алгоритм поиска в ширину

// Создадим массив
// в качестве имитации очереди
const searchQueue = [];

// Заполним массив именами
// первого уровня связи с "вы"
searchQueue.push(...graph["вы"]);

// Создадим функцию поиска продавца
function findSeller(queue) {

  // Пока список проверяемых людей не пуст
  while (queue.length > 0) {
    // Извлечем первого человека из списка
    let person = queue.shift();

    // заведем список уже проверенных
    const searched = new Set();

    // сначала проверим, не проверяли ли мы
    // уже этого человека
    if (!searched.has(person)) {

      // передадим его на проверку в функцию
      // которая определяет продавца по имени
      if (checkIsSeller(person)) {
        console.log(`${person} торгует огурцами!`);
        return;
      } else {
        // если не продавец 
        // добавим его друзей (внешних соседей)
        // в конец списка проверяемых
        queue.push(...graph[person]);
      }
    }
  }

  // если выполнение дошло сюда 
  // значит в графе нет торговца
  console.log("Торговец не найден");
  return;
};

// функция определения торговца по имени
function checkIsSeller(name) {
  return name.endsWith("м");
}

findSeller(searchQueue);


